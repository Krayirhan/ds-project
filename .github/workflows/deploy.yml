name: deploy

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:
    inputs:
      skip_staging:
        description: "Skip staging and deploy directly to prod (emergency only)"
        required: false
        default: "false"

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  HELM_CHART_PATH: deploy/helm/ds-project

jobs:
  # ‚îÄ‚îÄ 1. Build & Push Docker Image ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    outputs:
      image_tag: ${{ steps.meta.outputs.version }}
      image_digest: ${{ steps.build.outputs.digest }}
    steps:
      - uses: actions/checkout@v4

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.repository_owner }}
          password: ${{ github.token }}

      - name: Docker meta
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/krayirhan/ds-project
          tags: |
            type=sha,prefix=
            type=raw,value=latest,enable={{is_default_branch}}
          github-token: ${{ github.token }}

      - name: Build and push
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

  # ‚îÄ‚îÄ 2. Deploy to Staging ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  deploy-staging:
    runs-on: ubuntu-latest
    needs: build
    if: github.event.inputs.skip_staging != 'true'
    environment: staging
    outputs:
      did_deploy: ${{ steps.staging_guard.outputs.enabled }}
    steps:
      - uses: actions/checkout@v4

      - name: Check staging kubeconfig
        id: staging_guard
        shell: bash
        run: |
          if [ -n "${{ secrets.KUBE_CONFIG_STAGING }}" ]; then
            echo "enabled=true" >> "$GITHUB_OUTPUT"
          else
            echo "enabled=false" >> "$GITHUB_OUTPUT"
            echo "‚ÑπÔ∏è KUBE_CONFIG_STAGING is empty. Skipping staging deployment steps."
          fi

      - name: Install Helm
        if: steps.staging_guard.outputs.enabled == 'true'
        uses: azure/setup-helm@v3
        with:
          version: v3.14.0

      - name: Configure kubectl
        if: steps.staging_guard.outputs.enabled == 'true'
        uses: azure/k8s-set-context@v4
        with:
          kubeconfig: ${{ secrets.KUBE_CONFIG_STAGING }}

      - name: Deploy to staging namespace
        if: steps.staging_guard.outputs.enabled == 'true'
        run: |
          helm upgrade --install ds-project-staging ${{ env.HELM_CHART_PATH }} \
            --namespace ds-project-staging \
            --create-namespace \
            --values ${{ env.HELM_CHART_PATH }}/values.yaml \
            --values ${{ env.HELM_CHART_PATH }}/values-staging.yaml \
            --set image.tag=${{ needs.build.outputs.image_tag }} \
            --wait \
            --timeout 5m

      - name: Wait for rollout
        if: steps.staging_guard.outputs.enabled == 'true'
        run: |
          kubectl rollout status deployment/ds-project-staging \
            --namespace ds-project-staging \
            --timeout=180s

  # ‚îÄ‚îÄ 3. Smoke Tests on Staging ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  smoke-staging:
    runs-on: ubuntu-latest
    needs: deploy-staging
    if: needs['deploy-staging'].result == 'success' && needs['deploy-staging'].outputs.did_deploy == 'true'
    environment: staging
    steps:
      - uses: actions/checkout@v4

      - name: Check staging smoke secrets
        id: smoke_guard
        shell: bash
        run: |
          if [ -n "${{ secrets.KUBE_CONFIG_STAGING }}" ] && [ -n "${{ secrets.STAGING_API_KEY }}" ]; then
            echo "enabled=true" >> "$GITHUB_OUTPUT"
          else
            echo "enabled=false" >> "$GITHUB_OUTPUT"
            echo "‚ÑπÔ∏è Staging smoke secrets are missing. Skipping smoke steps."
          fi

      - name: Configure kubectl
        if: steps.smoke_guard.outputs.enabled == 'true'
        uses: azure/k8s-set-context@v4
        with:
          kubeconfig: ${{ secrets.KUBE_CONFIG_STAGING }}

      - name: Port-forward staging API
        if: steps.smoke_guard.outputs.enabled == 'true'
        run: |
          kubectl port-forward svc/ds-project-staging 8000:80 \
            --namespace ds-project-staging &
          sleep 5

      - name: Health check
        if: steps.smoke_guard.outputs.enabled == 'true'
        run: |
          response=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8000/health)
          if [ "$response" != "200" ]; then
            echo "‚ùå Health check failed with status $response"
            exit 1
          fi
          echo "‚úÖ Health check passed"

      - name: Readiness check
        if: steps.smoke_guard.outputs.enabled == 'true'
        run: |
          response=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8000/ready)
          if [ "$response" != "200" ]; then
            echo "‚ùå Readiness check failed with status $response"
            exit 1
          fi
          echo "‚úÖ Readiness check passed"

      - name: Metrics endpoint check
        if: steps.smoke_guard.outputs.enabled == 'true'
        run: |
          response=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8000/metrics)
          if [ "$response" != "200" ]; then
            echo "‚ùå Metrics check failed with status $response"
            exit 1
          fi
          echo "‚úÖ Metrics endpoint passed"

      - name: API v1 decide smoke test
        if: steps.smoke_guard.outputs.enabled == 'true'
        run: |
          response=$(curl -s -o /dev/null -w "%{http_code}" \
            -X POST http://localhost:8000/v1/decide \
            -H "Content-Type: application/json" \
            -H "x-api-key: ${{ secrets.STAGING_API_KEY }}" \
            -d '{"records": []}')
          echo "Decide endpoint returned: $response"

  # ‚îÄ‚îÄ 4. Approve for Production ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  approve-production:
    runs-on: ubuntu-latest
    needs: [build, smoke-staging]
    environment: production
    if: |
      always() &&
      needs.build.result == 'success' &&
      (needs['smoke-staging'].result == 'success' || needs['smoke-staging'].result == 'skipped')
    steps:
      - name: Approval gate
        run: echo "‚úÖ Production deployment approved ‚Äî manual review passed"

  # ‚îÄ‚îÄ 5. Deploy to Production ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  deploy-production:
    runs-on: ubuntu-latest
    needs: [build, approve-production]
    if: |
      always() &&
      needs.build.result == 'success' &&
      needs['approve-production'].result == 'success'
    steps:
      - uses: actions/checkout@v4

      - name: Check production kubeconfig
        id: prod_guard
        shell: bash
        run: |
          if [ -n "${{ secrets.KUBE_CONFIG_PRODUCTION }}" ]; then
            echo "enabled=true" >> "$GITHUB_OUTPUT"
          else
            echo "enabled=false" >> "$GITHUB_OUTPUT"
            echo "‚ÑπÔ∏è KUBE_CONFIG_PRODUCTION is empty. Skipping production deployment steps."
          fi

      - name: Install Helm
        if: steps.prod_guard.outputs.enabled == 'true'
        uses: azure/setup-helm@v3
        with:
          version: v3.14.0

      - name: Configure kubectl
        if: steps.prod_guard.outputs.enabled == 'true'
        uses: azure/k8s-set-context@v4
        with:
          kubeconfig: ${{ secrets.KUBE_CONFIG_PRODUCTION }}

      - name: Deploy to production
        if: steps.prod_guard.outputs.enabled == 'true'
        run: |
          helm upgrade --install ds-project ${{ env.HELM_CHART_PATH }} \
            --namespace ds-project \
            --create-namespace \
            --values ${{ env.HELM_CHART_PATH }}/values.yaml \
            --values ${{ env.HELM_CHART_PATH }}/values-production.yaml \
            --set image.tag=${{ needs.build.outputs.image_tag }} \
            --wait \
            --timeout 10m

      - name: Wait for rollout
        if: steps.prod_guard.outputs.enabled == 'true'
        run: |
          kubectl rollout status deployment/ds-project \
            --namespace ds-project \
            --timeout=300s

      - name: Post-deploy health check
        if: steps.prod_guard.outputs.enabled == 'true'
        run: |
          sleep 10
          kubectl exec -n ds-project \
            $(kubectl get pod -n ds-project -l app.kubernetes.io/name=ds-project -o jsonpath='{.items[0].metadata.name}') \
            -- python -c "import urllib.request; print(urllib.request.urlopen('http://127.0.0.1:8000/health', timeout=5).read())"

      - name: Notify deployment success
        if: success() && steps.prod_guard.outputs.enabled == 'true'
        run: |
          echo "üöÄ Production deployment completed: image=${{ needs.build.outputs.image_tag }}"

      - name: Notify deployment failure
        if: failure() && steps.prod_guard.outputs.enabled == 'true'
        run: |
          echo "üî¥ Production deployment FAILED: image=${{ needs.build.outputs.image_tag }}"
